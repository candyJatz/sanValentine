<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Te Amo ‚ù§Ô∏è - Visualizaci√≥n 3D</title>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            height: 100%;
            background: #000;
            overflow: hidden;
            font-family: Arial, sans-serif;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        /* Reproductor de audio - Nuevo dise√±o */
        .player {
            position: fixed;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 1000;
        }

        /* From Uiverse.io by bbaginuk */
        /*------ Settings ------*/
        .container {
            --color: white;
            --size: 45px;
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
            cursor: pointer;
            font-size: var(--size);
            user-select: none;
            fill: var(--color);
            width: 70px;
            height: 70px;
            border: 3px solid #ff6600;
            border-radius: 50%;
            background: rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(10px);
            box-shadow: 0 0 20px #ff6600, 0 0 40px #ff3300;
            transition: all 0.3s ease;
        }

        .container:hover {
            transform: scale(1.1);
            box-shadow: 0 0 30px #ff6600, 0 0 60px #ff3300;
        }

        .container .play {
            position: absolute;
            animation: keyframes-fill 0.3s;
            filter: drop-shadow(0 0 8px #ff6600);
        }

        .container .pause {
            position: absolute;
            display: none;
            animation: keyframes-fill 0.3s;
            filter: drop-shadow(0 0 8px #ff6600);
        }

        /* ------ On check event ------ */
        .container input:checked ~ .play {
            display: none;
        }

        .container input:checked ~ .pause {
            display: block;
        }

        /* ------ Hide the default checkbox ------ */
        .container input {
            position: absolute;
            opacity: 0;
            cursor: pointer;
            height: 0;
            width: 0;
        }

        /* ------ Animation ------ */
        @keyframes keyframes-fill {
            0% {
                transform: scale(0);
                opacity: 0;
            }
            50% {
                transform: scale(1.1);
            }
        }

        /* Loading indicator */
        .loading {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #fff;
            font-size: 18px;
            text-shadow: 0 0 10px #ff6600;
            z-index: 999;
        }
    </style>
</head>
<body>
    <canvas id="c"></canvas>

    <div class="loading" id="loading">Cargando experiencia 3D...</div>

    <div class="player">
        <label class="container">
            <input type="checkbox" id="playCheckbox" />
            <svg
                class="play"
                xmlns="http://www.w3.org/2000/svg"
                height="1em"
                viewBox="0 0 384 512"
            >
                <path
                    d="M73 39c-14.8-9.1-33.4-9.4-48.5-.9S0 62.6 0 80V432c0 17.4 9.4 33.4 24.5 41.9s33.7 8.1 48.5-.9L361 297c14.3-8.7 23-24.2 23-41s-8.7-32.2-23-41L73 39z"
                ></path>
            </svg>
            <svg
                class="pause"
                xmlns="http://www.w3.org/2000/svg"
                height="1em"
                viewBox="0 0 320 512"
            >
                <path
                    d="M48 64C21.5 64 0 85.5 0 112V400c0 26.5 21.5 48 48 48H80c26.5 0 48-21.5 48-48V112c0-26.5-21.5-48-48-48H48zm192 0c-26.5 0-48 21.5-48 48V400c0 26.5 21.5 48 48 48h32c26.5 0 48-21.5 48-48V112c0-26.5-21.5-48-48-48H240z"
                ></path>
            </svg>
        </label>
    </div>

    <audio id="audio" loop preload="metadata">

        <source src="Michael Giacchino - Stuff We Did.mp3" type="audio/mpeg">

        Tu navegador no soporta el elemento de audio.
    </audio>

    <script src="https://cdn.jsdelivr.net/npm/three@0.148.0/build/three.min.js"></script>
    <script>
        // ============================================
        // REPRODUCTOR DE AUDIO
        // ============================================
        const audio = document.getElementById('audio');
        const playCheckbox = document.getElementById('playCheckbox');
        const loadingEl = document.getElementById('loading');

        // Play/Pause con el checkbox
        playCheckbox.addEventListener('change', async () => {
            try {
                if (playCheckbox.checked) {
                    await audio.play();
                } else {
                    audio.pause();
                }
            } catch (error) {
                console.error('Error al reproducir audio:', error);
                playCheckbox.checked = false;
            }
        });

        // Sincronizar el checkbox con el estado del audio
        audio.addEventListener('play', () => {
            playCheckbox.checked = true;
        });

        audio.addEventListener('pause', () => {
            playCheckbox.checked = false;
        });

        // ============================================
        // VISUALIZACI√ìN 3D CON THREE.JS
        // ============================================
        const canvas = document.getElementById('c');
        const renderer = new THREE.WebGLRenderer({
            canvas: canvas,
            antialias: true,
            alpha: false
        });

        renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));
        renderer.setSize(window.innerWidth, window.innerHeight);

        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(
            60,
            window.innerWidth / window.innerHeight,
            0.1,
            5000
        );

        // Variables de c√°mara
        let targetDist = 300;
        let currentDist = 300;
        let rotX = 0.2;
        let rotY = 0;

        // Cargar textura de fondo (nebulosa)
        const loader = new THREE.TextureLoader();
        loader.load(
            'https://raw.githubusercontent.com/mrdoob/three.js/dev/examples/textures/cube/space/px.jpg',
            (texture) => {
                scene.background = texture;
                loadingEl.style.display = 'none';
            },
            undefined,
            (error) => {
                console.error('Error cargando textura:', error);
                scene.background = new THREE.Color(0x000000);
                loadingEl.style.display = 'none';
            }
        );

        // ============================================
        // CREAR ESTRELLAS DE FONDO
        // ============================================
        function createStars(count = 2000, radius = 3000) {
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(count * 3);

            for (let i = 0; i < count; i++) {
                const r = radius * (0.3 + 0.7 * Math.random());
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);

                positions[i * 3 + 0] = r * Math.sin(phi) * Math.cos(theta);
                positions[i * 3 + 1] = r * Math.cos(phi);
                positions[i * 3 + 2] = r * Math.sin(phi) * Math.sin(theta);
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));

            const material = new THREE.PointsMaterial({
                size: 1.5,
                color: 0xffffff,
                depthWrite: false
            });

            const stars = new THREE.Points(geometry, material);
            scene.add(stars);
        }

        createStars();

        // ============================================
        // N√öCLEO CENTRAL (ESFERA)
        // ============================================
        const coreMaterial = new THREE.MeshPhongMaterial({
            color: 0x1111111,
            transparent: true,
            opacity: 0.6,
            shininess: 200
        });

        const core = new THREE.Mesh(
            new THREE.SphereGeometry(40, 64, 64),
            coreMaterial
        );
        scene.add(core);

        // ============================================
        // TEXTO CENTRAL "TE AMO ‚ù§Ô∏è"
        // ============================================
        function makeCenterTextTexture(text) {
            const canvas = document.createElement('canvas');
            canvas.width = 512;
            canvas.height = 512;
            const ctx = canvas.getContext('2d');

            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.font = 'bold 80px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillStyle = '#ff0033';
            ctx.shadowColor = '#ff66aa';
            ctx.shadowBlur = 50;
            ctx.fillText(text, canvas.width / 2, canvas.height / 2);

            return new THREE.CanvasTexture(canvas);
        }

        const centerTexture = makeCenterTextTexture('TE AMO ‚ù§Ô∏è');
        const centerMaterial = new THREE.SpriteMaterial({
            map: centerTexture,
            transparent: true
        });
        const centerSprite = new THREE.Sprite(centerMaterial);
        centerSprite.scale.set(60, 60, 1);
        centerSprite.position.set(0, 0, 0);
        centerSprite.renderOrder = 999;
        scene.add(centerSprite);

        // ============================================
        // RESPLANDOR (GLOW)
        // ============================================
        function makeGlowTexture(size = 768, innerColor = '255,160,0', outerColor = '255,60,0') {
            const canvas = document.createElement('canvas');
            canvas.width = canvas.height = size;
            const ctx = canvas.getContext('2d');

            const gradient = ctx.createRadialGradient(
                size / 2, size / 2, size * 0.05,
                size / 2, size / 2, size * 0.5
            );

            gradient.addColorStop(0, `rgba(${innerColor}, 0.9)`);
            gradient.addColorStop(0.5, `rgba(${outerColor}, 0.5)`);
            gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');

            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, size, size);

            return new THREE.CanvasTexture(canvas);
        }

        const glowSprite = new THREE.Sprite(new THREE.SpriteMaterial({
            map: makeGlowTexture(),
            transparent: true,
            depthWrite: false
        }));
        glowSprite.scale.set(500, 500, 1);
        scene.add(glowSprite);

        // ============================================
        // ANILLOS
        // ============================================
        function createRingTexture(size = 768) {
            const canvas = document.createElement('canvas');
            canvas.width = canvas.height = size;
            const ctx = canvas.getContext('2d');

            ctx.translate(size / 2, size / 2);

            const innerRadius = size * 0.34;
            const outerRadius = size * 0.49;

            const gradient = ctx.createRadialGradient(
                0, 0, innerRadius * 0.3,
                0, 0, outerRadius
            );

            gradient.addColorStop(0, 'rgba(255, 255, 200, 1)');
            gradient.addColorStop(0.3, 'rgba(255, 160, 60, 0.9)');
            gradient.addColorStop(0.65, 'rgba(255, 80, 0, 0.6)');
            gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');

            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(0, 0, outerRadius, 0, Math.PI * 2);
            ctx.arc(0, 0, innerRadius, 0, Math.PI * 2, true);
            ctx.closePath();
            ctx.fill();

            return new THREE.CanvasTexture(canvas);
        }

        const ringTexture = createRingTexture();

        const ring1 = new THREE.Mesh(
            new THREE.RingGeometry(60, 80, 128),
            new THREE.MeshBasicMaterial({
                map: ringTexture,
                transparent: true,
                side: THREE.DoubleSide
            })
        );

        const ring2 = new THREE.Mesh(
            new THREE.RingGeometry(85, 100, 128),
            new THREE.MeshBasicMaterial({
                map: ringTexture,
                transparent: true,
                side: THREE.DoubleSide,
                opacity: 0.6
            })
        );

        ring1.rotation.x = ring2.rotation.x = Math.PI / 2;
        scene.add(ring1);
        scene.add(ring2);

        // ============================================
        // PALABRAS FLOTANTES
        // ============================================
        const baseWords = [
            "üíñ Mi amor", "üåû Mi sol", "üåé Mi mundo", "‚ú® Brillas",
            "‚ù§Ô∏è Te amo", "üåå Mi Universo", "üëë my lord", "üå† mi estrella fugaz",
            "üí´ Mi cielo", "üî• love you ", "üé∂ Tu risa", "ü¶ã tan lindo como el Amanecer",
            "üíé Eres todo", "üôè Gracias ", "üíï Cari√±o", "üåπ amor fugaz",
            "ü§ó Abrazitos", "üå∏ tus ojos como lucero", "üåà feli cuando hablamos", "üåü Contigo",
            "üß∏ mi ternura", "üéÅ Mi raz√≥n de ir a la escuela", "üåô Mi luna", "üíå Recuerdos juntos",
            "üïäÔ∏è Mi paz", "ü™ê Mi universo", "üåä Mi calma", "üí° Mi luz",
            "üçí Dulzura", "ü•∞ Mi vida", "üéá Felicidad", "üåª Alegr√≠a",
            "üå∫ Mi flor", "üíú inefable", "üåü mis Sue√±os", "‚ú®mi Magia",
            "üéµ mi melodia favorita", "üî•hot", "‚≠ê Mi estrella", "üå¥ Mi para√≠so",
            "üåÑ Amanecer", "üåÉ Noche contigo", "üéâ Mi fiesta", "üí´ Inspiraci√≥n",
            "üå∑ mi ni√±o", "üéÄ Mi lucero", "üçÄ Mi fortuna", "ü™û Mi reflejo"
        ];

        // Multiplicar palabras para tener m√°s
        const WORDS = [];
        for (let i = 0; i < 6; i++) {
            WORDS.push(...baseWords);
        }

        const COLORS = [
            '#ff66ff', '#66ccff', '#ffd36b', '#ff9966', '#8df59a',
            '#ffa0f8', '#c6a7ff', '#ff4444', '#44ff99', '#99ccff'
        ];

        function makeTextTexture(text, shadowColor) {
            const canvas = document.createElement('canvas');
            canvas.width = 512;
            canvas.height = 128;
            const ctx = canvas.getContext('2d');

            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.font = 'bold 60px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillStyle = '#fff';
            ctx.shadowColor = shadowColor;
            ctx.shadowBlur = 30;
            ctx.fillText(text, canvas.width / 2, canvas.height / 2);

            return new THREE.CanvasTexture(canvas);
        }

        const textGroup = new THREE.Group();
        scene.add(textGroup);

        // Crear sprites de texto
        for (let i = 0; i < WORDS.length; i++) {
            const texture = makeTextTexture(WORDS[i], COLORS[i % COLORS.length]);
            const material = new THREE.SpriteMaterial({
                map: texture,
                transparent: true
            });
            const sprite = new THREE.Sprite(material);
            sprite.scale.set(50, 16, 1);

            // Posici√≥n esf√©rica aleatoria
            const phi = Math.acos(2 * Math.random() - 1);
            const theta = Math.random() * Math.PI * 2;
            const radius = 150 + 120 * Math.random();

            sprite.position.set(
                radius * Math.sin(phi) * Math.cos(theta),
                radius * Math.cos(phi),
                radius * Math.sin(phi) * Math.sin(theta)
            );

            // Guardar datos para animaci√≥n
            sprite.userData = {
                phi: phi,
                theta: theta,
                radius: radius,
                speed: 0.001 + 0.001 * Math.random()
            };

            textGroup.add(sprite);
        }

        // ============================================
        // CONTROLES DE C√ÅMARA (MOUSE/TOUCH)
        // ============================================
        let dragging = false;
        let lastX = 0;
        let lastY = 0;

        function onPointerDown(e) {
            dragging = true;
            const point = e.touches ? e.touches[0] : e;
            lastX = point.clientX;
            lastY = point.clientY;
        }

        function onPointerMove(e) {
            if (!dragging) return;

            const point = e.touches ? e.touches[0] : e;
            const deltaX = (point.clientX - lastX) / window.innerWidth;
            const deltaY = (point.clientY - lastY) / window.innerHeight;

            rotY -= deltaX * 3;
            rotX = Math.max(-1.2, Math.min(1.2, rotX - deltaY * 2.2));

            lastX = point.clientX;
            lastY = point.clientY;
        }

        function onPointerUp() {
            dragging = false;
        }

        // Mouse events
        canvas.addEventListener('mousedown', onPointerDown);
        canvas.addEventListener('mousemove', onPointerMove);
        canvas.addEventListener('mouseup', onPointerUp);
        canvas.addEventListener('mouseleave', onPointerUp);

        // Touch events
        canvas.addEventListener('touchstart', onPointerDown, { passive: true });
        canvas.addEventListener('touchmove', onPointerMove, { passive: true });
        canvas.addEventListener('touchend', onPointerUp, { passive: true });

        // Zoom con rueda del mouse
        canvas.addEventListener('wheel', (e) => {
            e.preventDefault();
            targetDist += e.deltaY * 0.25;
            targetDist = Math.max(160, Math.min(600, targetDist));
        }, { passive: false });

        // Pinch zoom para m√≥viles
        let lastPinchDistance = 0;

        canvas.addEventListener('touchmove', (e) => {
            if (e.touches && e.touches.length === 2) {
                e.preventDefault();

                const dx = e.touches[0].clientX - e.touches[1].clientX;
                const dy = e.touches[0].clientY - e.touches[1].clientY;
                const distance = Math.hypot(dx, dy);

                if (lastPinchDistance) {
                    const delta = lastPinchDistance - distance;
                    targetDist += delta * 0.5;
                    targetDist = Math.max(160, Math.min(600, targetDist));
                }

                lastPinchDistance = distance;
            }
        }, { passive: false });

        canvas.addEventListener('touchend', () => {
            lastPinchDistance = 0;
        }, { passive: true });

        // ============================================
        // RESIZE HANDLER
        // ============================================
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // ============================================
        // LOOP DE ANIMACI√ìN
        // ============================================
        let time = 0;

        function animate() {
            requestAnimationFrame(animate);
            time += 0.01;

            // Rotar anillos
            ring1.rotation.z += 0.002;
            ring2.rotation.z -= 0.0015;

            // Pulsar resplandor
            const glowScale = 500 * (1 + 0.03 * Math.sin(time * 0.4));
            glowSprite.scale.set(glowScale, glowScale, 1);

            // Pulsar n√∫cleo
            const coreScale = 1 + 0.05 * Math.sin(time * 3);
            core.scale.set(coreScale, coreScale, coreScale);

            // Animar palabras flotantes
            textGroup.children.forEach((sprite) => {
                // Opacidad pulsante
                sprite.material.opacity = 0.8 + 0.2 * Math.sin(time * 2);

                // Rotaci√≥n orbital
                sprite.userData.theta += sprite.userData.speed;

                const phi = sprite.userData.phi;
                const theta = sprite.userData.theta;
                const r = sprite.userData.radius;

                sprite.position.x = r * Math.sin(phi) * Math.cos(theta);
                sprite.position.z = r * Math.sin(phi) * Math.sin(theta);
            });

            // Suavizar movimiento de c√°mara
            currentDist += (targetDist - currentDist) * 0.06;

            // Posicionar c√°mara
            const cosX = Math.cos(rotX);
            const sinX = Math.sin(rotX);
            const cosY = Math.cos(rotY);
            const sinY = Math.sin(rotY);

            camera.position.set(
                currentDist * sinY * cosX,
                currentDist * sinX,
                currentDist * cosY * cosX
            );
            camera.lookAt(0, 0, 0);

            // Renderizar escena
            renderer.render(scene, camera);
        }

        // Iniciar animaci√≥n
        animate();

        // Ocultar loading despu√©s de 1 segundo si no se ha cargado la textura
        setTimeout(() => {
            loadingEl.style.display = 'none';
        }, 1000);
    </script>
</body>
</html>
